<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>SoonSpace Example</title>
  <link rel="stylesheet" href="../../asstes/css/base.css">
  <link rel="stylesheet" href="../../asstes/css/tool.css">
</head>

<body>
  <div id="view"></div>

  <script src="../../sdk/index.js"></script>
  <script>

    const ssp = new SoonSpace({
      el: '#view',
      option: {
        showInfo: true
      },
      events: {}
    })
    const baseUrl = '../../asstes/model/sbm/oneroom'
    const mapsUrl = `${baseUrl}/Maps/`
    ssp.loadSbm({
      id: 'f',
      mapsUrl,
      url: `${baseUrl}/oneroom_1F_0.sbm`,
    })
      .then(model => {
        console.log(model)
        aaa(model)
      })

    function aaa(model, option = {}) {

      const {
        divisions = 20
      } = option

      const bb = model.getBoundingBox()

      // model.hide()

      const modelXLen = bb.max.x - bb.min.x
      const modelYLen = bb.max.y - bb.min.y
      const modelZLen = bb.max.z - bb.min.z

      console.log(modelXLen, modelYLen, modelZLen)

      const bbSize = Math.max(modelXLen, modelZLen)
      const size = bbSize * divisions

      // ssp.addGridHelper({
      //   divisions,
      //   size,
      //   color: 0xffffff
      // })

      const THREE = ssp.viewport.THREE

      const rollOverGeo = new THREE.BoxBufferGeometry(modelXLen, modelYLen, modelZLen);
      const rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
      const rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
      rollOverMesh.position.set(modelXLen / 2, modelYLen / 2, modelZLen / 2)

      ssp.viewport.scene.add(rollOverMesh)

      const geometry = new THREE.PlaneBufferGeometry(modelXLen * divisions, modelZLen * divisions);
      geometry.rotateX(- Math.PI / 2);

      const plane = new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({ color: 0x999999 }));
      ssp.viewport.scener.addObject(plane)

      ssp.viewport._setStateProp('mouseMoveEnabled', true)
      ssp.viewport._setStateProp('mouseDownEnabled', true)
      ssp.viewport.signals.mouseMove.add(intersects => {
        if (intersects.length > 0) {

          const intersect = intersects[0];

          if (intersect.point && intersect.face) {
            rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
            rollOverMesh.position.divideScalar(modelXLen).floor().multiplyScalar(modelZLen).addScalar(modelYLen / 2);
            ssp.viewport.trigerRender()
          }

        }
      })

      ssp.viewport.signals.mouseDown.add(intersects => {
        const m = rollOverMesh.clone()
        console.log(m)
        ssp.viewport.scener.addObject(m)
        ssp.viewport._setStateProp('mouseDownEnabled', false)

      })

    }

  </script>
</body>

</html>